//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Data;


/*
 * TableProcessor class calculates the DFs and IDF values from given Database for preprocessing the metaDatabase. 
 * Also posseses functions to interpolate between 2 numerical values and calculating the idf value of numerical values. 
 */

public class TableProccessor
{

    public static DatabaseConnection connection;
    public static Dictionary<string, ColumnProperties> ColumnProperties = new Dictionary<string, ColumnProperties>();
    private static DataTable table = null;
    private static int numberofRows;

    /// <summary>
    /// creates and filles a table according to the raw sql supplied
    /// </summary>
    /// <param name="sql"></param>
    public static void CreateAndFillTable(string sql)
    {
        connection.runCreationSql(sql);
    }

    /// <summary>
    /// retrieves the autompg table, not sure yetif needed, but here it is anyways.
    /// </summary>
    /// <returns></returns>
    public static DataTable RetrieveTable()
    {
        if (!(table == null))
            return table;

        table = connection.QueryForDataTable("SELECT * FROM autompg");
        numberofRows = table.Rows.Count;
        return table;
    }
    
    public static int GetDistinct(string columname)
    {
        DataTable count = connection.QueryForDataTable("SELECT COUNT (*) FROM (SELECT DISTINCT " + columname + " FROM autompg)");
        var temp = count.Rows[0][0];
        return Convert.ToInt32(temp);
    }

    /// <summary>
    /// should calculate the idf values and tell the metaDbFiller to fill the metaDB
    /// </summary>
    /// <param name="table"></param>
    public static void Process()
	{
        //voor iedere column check if numerical
        foreach (var column in ColumnProperties)
        {
            if (column.Key.ToLower() == "id")
                continue;

            column.Value.distinctValues = GetDistinct(column.Key);

            if (column.Value.numerical.HasValue && !column.Value.numerical.Value)
            {
                int max = 0; // we decided to devide by the maximum number of occurrences instead of amount of documents
                             // because the intention of using IDF is to have the most common terms being log(1) (frequent terms occur in basically any document)
                              
                          
                Dictionary<string,int> Dfs = GetDfsForText(column.Key, ref max);
                // implement idf
                double idfDevider = Math.Abs(Math.Log10(1.0d / max));  // to make idf a scalar
                Dictionary<string, double> IDFS = new Dictionary<string, double>();
                foreach (var DF in Dfs)
                {
                    double idf;// TODO Deze berekening geeft nog waarden boven 1 
                    
                    idf = Math.Abs(Math.Log10((double)numberofRows / (double)DF.Value));//kan heel goed door opencl gedaan
                    
                    IDFS.Add(DF.Key, idf);
                }

                //write to table in metadb
                MetaDbFiller.IdfMetaTable(column.Key, IDFS);
            }
            else
            {
                Dictionary<double, double> Idfs = getIdfsForNumerical(column.Key);
                // write to table in metadb
                MetaDbFiller.IdfMetaTable(column.Key, Idfs);
            }
        }
        //throw new NotImplementedException("meta table not yet implemented, check its idf for values");
        int i = 0;

	}

    ///gets a dictionary from value to amount of occurrences and max occurrences
    public static Dictionary<string, int> GetDfsForText(string columname, ref int max)
    {
        Dictionary<string, int> DFs = new Dictionary<string, int>();

        //grouped column values so the sqlite takes over the workload, might come at hand when extending this
        DataTable column = connection.QueryForDataTable("SELECT " + columname + " FROM autompg  ORDER BY " + columname + " ASC;");
        int j = 1;
        string lastvalue = "";
        for (int i = 0; i < column.Rows.Count; i++)
        {
            if ((string)column.Rows[i][columname] == lastvalue)
            {
                j++;
            }
            else if (i > 0)
            {
                DFs.Add(lastvalue, j);
                if (j > max)
                    max = j;
                j = 1;
                lastvalue = (string)column.Rows[i][columname];
            }
            else
            {
                lastvalue = (string)column.Rows[i][columname];
            }
        }
        return DFs;
    }

    /// <summary>
    /// gets the log of the amount of distinct values
    /// </summary>
    /// <param name="columname"></param>
    /// <returns></returns>
    private static double TryGetIntervalSize(string columname)
    {
        if (ColumnProperties[columname].GetInterval() == 0)
        {
            return GetIntervalSize(columname);

        }

        return ColumnProperties[columname].GetInterval();
    }

    /// <summary>
    /// gets the interval sizes of the given columname
    /// </summary>
    /// <param name="columname"></param>
    /// <returns></returns>
    public static double GetIntervalSize(string columname)
    {
        // 
        int distinct = ColumnProperties[columname].distinctValues;
        int intervals = (int)(10.0d * Math.Log(ColumnProperties[columname].distinctValues));//10 * log(distinct) intervals zorgen dat je niet 0 krijgt
        double size = (ColumnProperties[columname].max - ColumnProperties[columname].min) / ((double)(intervals));
        if (!ColumnProperties[columname].numerical.HasValue)
        {
            if(size < 1)//size onder 1 heeft geen zin bij andere sizes rounden
            {
                intervals = (int)(ColumnProperties[columname].max - ColumnProperties[columname].min);
                size = 1;
            }
            else//anders geheel getal nemen
            {
                size = Math.Round(size);
                intervals = (int)Math.Ceiling((ColumnProperties[columname].max - ColumnProperties[columname].min) / size);
            }


        }
        ColumnProperties[columname].SetInterval(size);
        return size;
    }

    /// <summary>
    /// gets all the idfs for numerical values
    /// </summary>
    /// <param name="columname"></param>
    /// <returns></returns>
    public static Dictionary<double, double> getIdfsForNumerical(string columname)
    {
        Dictionary<double, double> idfs = new Dictionary<double, double>();
        //grouped column values so the sqlite takes over the workload, might come at hand when extending this
        ColumnProperties properties = ColumnProperties[columname];
        for (double d = properties.min; d <= properties.max; d += TryGetIntervalSize(columname))
        {
            idfs.Add(d, GetNumeralIdf(columname, d));
        }

        return idfs;
    }

    /// <summary>
    /// gets an idf value for numeral input
    /// </summary>
    /// <param name="columname"></param>
    /// <param name="u"></param>
    /// <returns></returns>
    public static double GetNumeralIdf(string columname, double u)
    {
        DataTable column = connection.QueryForDataTable("SELECT " + columname + " FROM autompg  ORDER BY " + columname + " ASC;" );

        ColumnProperties properties = ColumnProperties[columname];

        //idf(t) = log (n / d) = log(n) - log(d) 
        //d = sum of e ^ (-0,5*f) ^ 2
        //f = (ti -u ) / h 
        // where (i is the counter of the sum) AND (i E [0,...n]) AND h is the total bandwith

        double d = 0;

        foreach (DataRow row in column.Rows)
        {
            //f = (ti -u ) / h 
            //f = afstand / max mogelijke afstand
            double f = (Convert.ToDouble(row[columname]) - u) / (properties.max - properties.min);
            
            //d = sum of e ^ (-0,5*f) ^ 2
            double g = Math.Pow(Math.E, (-0.5 * Math.Pow( f, 2)));
            d += g;
        }

        //idf(t) = log (n / d) 
        double idf = Math.Abs( 10 * (Math.Log(column.Rows.Count / d, Math.E))); //TODO: testen of je niet moet delen door log10*columns.rows.count om scalar te krijgen

        return idf;
    }
    /*
    public static double calculateQfIdfNumeral(string columnname, List<SQLQuery> Workload, int n, double u)
    {
        double qfidf = 0;
        double qf = 0;
        double idf = 0;

        idf = GetNumeralIdf(columnname, u);
        qf = WorkloadProcessor.getNumericalQFFromU(u, Workload, columnname, n);

        qfidf = idf * qf;
        return qfidf;

    }

    public static Dictionary<double, double> getQfIdfNumeral(string columnname, List<SQLQuery> Workload, int n, double u)
    {
        Dictionary<double, double> qfidf = new Dictionary<double, double>();
        double value = calculateQfIdfNumeral(columnname, Workload, n, u);
        ColumnProperties properties = ColumnProperties[columnname];

        for (double d = properties.min; d <= properties.max; d += TryGetIntervalSize(columnname))
        {
            qfidf.Add(d, value);
        }
        return qfidf;
    }
    */

    /// <summary>
    /// Fixes all the columnProperties from the database
    /// </summary>
    public static void CalculateColumnProperties()
    {
        List<string> columnNames = new List<string>();

        DataTable tableInfo = connection.QueryForDataTable("PRAGMA table_info('autompg')");
        foreach (DataRow row in tableInfo.Rows)
        {
            columnNames.Add((string)row[tableInfo.Columns[1]]);
        }

        for (int i = 0; i < tableInfo.Rows.Count; i++)
        {
            bool? numerical;
            double smallest = 0;
            double largest = 0;
            DataRow row = tableInfo.Rows[i];
            if (row[tableInfo.Columns[2]].ToString().ToLower().Contains("text"))
            {
                numerical = false;
            }
            //integer values hebben altijd weinig mogelijkheden, 
            else
            {
                if (row[tableInfo.Columns[2]].ToString().ToLower().Contains("integer"))
                {
                    numerical = null;//TODO moet voor integers tot n bepaald distinct limiet null zijn
                    DataTable min = connection.QueryForDataTable("SELECT  " + columnNames[i] + " FROM autompg ORDER BY " + columnNames[i] + " ASC LIMIT 1;");
                    // select smallest value
                    var small = min.Rows[0][0];
                    smallest = Convert.ToDouble(small);
                    // select largest value
                    DataTable max = connection.QueryForDataTable("SELECT " + columnNames[i] + " FROM autompg ORDER BY " + columnNames[i] + " DESC LIMIT 1;");
                    var large = max.Rows[0][0];
                    largest = Convert.ToDouble(large);
                }
                else
                {
                    numerical = true;
                    DataTable min = connection.QueryForDataTable("SELECT  " + columnNames[i] + " FROM autompg ORDER BY " + columnNames[i] + " ASC LIMIT 1;");
                    // select smallest value
                    smallest = (double)min.Rows[0][0];
                    // select largest value
                    DataTable max = connection.QueryForDataTable("SELECT " + columnNames[i] + " FROM autompg ORDER BY " + columnNames[i] + " DESC LIMIT 1;");
                    largest = (double)max.Rows[0][0];

                }
            }



            ColumnProperties.Add(columnNames[i], new ColumnProperties(numerical, columnNames[i])
            {
                min = smallest,
                max = largest
            }
            );

        }
    }
    
}


