//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class WorkloadProcessor
{


    /// <summary>
    /// here the QF Values and where appliccable the Jaccard coefficients should be calculated
    /// </summary>
    /// <param name="Workload"></param>
    public static void Process(SQLQuery[] Workload)
    {

        foreach (var column in TableProccessor.ColumnProperties)
        {
            if ( column.Key != "id" && (column.Value.numerical != null && !column.Value.numerical.Value))
            {
                GetNonNumericalQfs(Workload, column.Key);
                GetJaquards(Workload, column.Key);
            }
            else if (column.Key != "id")
            {
                GetNumericalQf(Workload, column.Key);
            }

        }


    }

    /// <summary>
    /// gets all the jaccard coefficients
    /// </summary>
    /// <param name="Workload"></param>
    /// <param name="columname"></param>
    public static void GetJaquards(SQLQuery[] Workload, string columname)
    {
        bool useful = false;
        foreach (var query in Workload)//first check if there is any need at all to calculate 
        {
            if (!useful && query.requiredValues.ContainsKey(columname) && query.requiredValues[columname].Length > 1)
            {
                useful = true;
                break;
            }
        }
        
        if (! useful)
        {
            return;
        }
        
        List<SQLQuery> relevantQueries = new List<SQLQuery>();
        foreach (var query in Workload)//only select queries with any relevant info
        {
            if (query.requiredValues.ContainsKey(columname))
            {
                relevantQueries.Add(query);
            }
        }

        Dictionary<string, object> jaquards = new Dictionary<string, object>();
        foreach(var idf in MetaDbFiller.idfs[columname] as Dictionary<string, double>)
        {
            Dictionary<string, double> jaquard = new Dictionary<string, double>();
            foreach(var idf2 in MetaDbFiller.idfs[columname] as Dictionary<string, double>)
            {
                jaquard.Add(idf2.Key, Jaquard(relevantQueries, idf.Key, idf2.Key, columname));
            }
            jaquards.Add(idf.Key,jaquard);
        }


        MetaDbFiller.AddJaquardsMetaTable(columname, jaquards);
    }

    
    /// <summary>
    /// calculate the jaquard coefficient for two terms
    /// </summary>
    /// <param name="relevant"></param>
    /// <param name="term1"></param>
    /// <param name="term2"></param>
    /// <param name="columname"></param>
    /// <returns></returns>
    public static double Jaquard(List<SQLQuery> relevant, string term1, string term2, string columname)
    {
        int union = 0, intersection = 0;
        if (term1 == term2)
            return 1;

        foreach (var query in relevant)
        {
            if (query.requiredValues[columname].Contains(term1))
            {
                union += query.times ;
                if (query.requiredValues[columname].Contains(term2))
                    intersection += query.times;

            }
            else if (query.requiredValues[columname].Contains(term2))
            {
                union += query.times;
            }
        }

        if (union > 0 && intersection == 0)
        {
            return 0;
        }

        return (double)intersection / (double)union ;
    }

    /// <summary>
    /// Get All Qfs for non numerical values
    /// </summary>
    /// <param name="Workload"></param>
    /// <param name="columname"></param>
    public static void GetNonNumericalQfs(SQLQuery[] Workload, string columname)
    {
        Dictionary<object, int> pairing = new Dictionary<object, int>();//coupling between the location in the timeDictionary and a string
        List<int> timeDictionary = new List<int>();//raw amount of occurrences
        int counter = 0;

        foreach (SQLQuery query in Workload)
        {
            if (query.requiredValues.ContainsKey(columname))
            {
                object[] values = query.requiredValues[columname];
                int times = query.times;
                foreach (var value in values)
                {
                    if (!pairing.ContainsKey(value))//saves pairing between location in timedictionary and string index
                    {
                        pairing.Add(value, counter);
                        timeDictionary.Add(times);
                        counter++;
                    }
                    else
                    {
                        int index = pairing[value];
                        timeDictionary[index] += times;
                    }

                }
            }
        }
        Dictionary<string, double> qfs = new Dictionary<string, double>();
        if (timeDictionary.Count == 0)
        {
            foreach (var entry in (MetaDbFiller.idfs[columname] as Dictionary<string, double>))
            {
                qfs.Add(entry.Key, 1.0);//add qf value of 1 if never searched for yet
            }
        }
        else
        {
            double rqfmax = (double)timeDictionary.Max();
            foreach (var pair in pairing)
            {
                double qf = timeDictionary[pair.Value] / rqfmax;
                qfs.Add(pair.Key.ToString(), qf);//add scalar qf if not
            }
        }
        MetaDbFiller.AddQfMetaTable(columname, qfs);

    }

    /// <summary>
    /// get all numerical qfs
    /// </summary>
    /// <param name="Workload"></param>
    /// <param name="columname"></param>
    public static void GetNumericalQf(SQLQuery[] Workload, string columname)
    {
        double size = TableProccessor.GetIntervalSize(columname);
        ColumnProperties properties = TableProccessor.ColumnProperties[columname];
        List<SQLQuery> relevantQueries = new List<SQLQuery>();
        int total = 0;
        foreach(var query in Workload)
        {
            if (query.requiredValues.ContainsKey(columname))//only relevant queries are being used
            {
                relevantQueries.Add(query);
                total += query.times;
            }
        }
        Dictionary<double, double> Qfs = new Dictionary<double, double>();
        Dictionary<double, double> RQfs = new Dictionary<double, double>();
        double RQfMax = 0;
        for (double d /*bij het ontbijt*/ = properties.min; d <= properties.max; d += size)
        {
            double qf = getNumericalQFFromU(d, relevantQueries, columname, total);
            RQfs.Add(d,qf);
            if (RQfMax < qf)
                RQfMax = qf;
        }

        foreach (var Qf in RQfs)
            Qfs.Add(Qf.Key, Qf.Value / RQfMax);

        MetaDbFiller.AddQfMetaTable(columname, Qfs);

        relevantQueries = null;//memory cleanup
        GC.Collect();
    }


    /// <summary>
    /// retrieve a specific value. U is the value, n total ammount of queries
    /// </summary>
    /// <param name="u"></param>
    /// <param name="Workload"></param>
    /// <param name="columname"></param>
    /// <param name="n"></param>
    /// <returns></returns>
    public static double getNumericalQFFromU(double u, List<SQLQuery> Workload, string columname, int n)
    {
        double qf = 0;

        foreach (SQLQuery query in Workload)
        {
            ColumnProperties properties = TableProccessor.ColumnProperties[columname];
            object[] values = query.requiredValues[columname];

            // similar to the calculation of Idf the queried values represent guidance locations 
            foreach (var value in values)
            {
                double ti;
                ti = Convert.ToDouble(value);//using which we will approximate the results of a function
                double temp = 0.5 * (Math.Pow(((ti - u) / (properties.max - properties.min / 2)), 2)) / n;
                qf += temp * query.times;
            }
        }
        return qf;

    }

}

